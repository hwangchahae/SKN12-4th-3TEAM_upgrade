<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>github ai 코드 분석 챗봇</title>
  <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet"/>
  <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet"/>
  <!-- Three.js 라이브러리 추가 -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    html, body {
      height: 300vh;
      background: linear-gradient(to bottom, #05054d 0%, #1a1a40 50%, #305d7f 100%);
      font-family: Arial, sans-serif;
      overflow-x: hidden;
      color: white;
    }

    .hero {
      position: fixed;
      width: 100%;
      height: 100vh;
      display: flex;
      flex-direction: column;
      justify-content: flex-start;
      align-items: center;
      z-index: 500;
      text-align: center;
      padding-top: 160px;
      pointer-events: none; /* 텍스트는 클릭 불가, 버튼만 클릭 가능 */
    }

    /* 3D 컨테이너 스타일 */
    .hero-3d-container {
      position: fixed;
      bottom: 0;
      left: 50%;
      transform: translateX(-50%);
      width: 100%;
      height: 80vh;
      z-index: 1;
      pointer-events: none;
    }

    /* 배경 이미지 스타일 */
    .background-image {
      position: fixed;
      bottom: 0;
      left: 50%;
      transform: translateX(-50%) scale(1.5);
      z-index: 0;
      max-width: 100%;
      max-height: 80vh;
      object-fit: contain;
      pointer-events: none;
      opacity: 0.8;
    }

    /* 3D 캔버스 스타일 */
    #three-canvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 2;
      pointer-events: auto;
      clip-path: inset(220px 0 0 0); /* 상단 버튼 영역 제외 */
    }

    .btn {
      font-size: 1.2rem;
      padding: 1rem 2.5rem;
      border: none;
      outline: none;
      border-radius: 0.4rem;
      cursor: pointer;
      text-transform: uppercase;
      background-color: rgb(17, 17, 153);
      color: rgb(234, 234, 234);
      font-weight: 700;
      transition: all 0.4s ease;
      box-shadow: 0px 0px 60px #2793ce;
      -webkit-box-reflect: below 10px linear-gradient(to bottom, rgba(0,0,0,0.0), rgba(0,0,0,0.4));
      margin-top: 2rem;
      position: relative;
      z-index: 1000;
      pointer-events: auto;
    }

    .btn:hover {
      background: linear-gradient(270deg, rgba(2, 29, 78, 0.681) 0%, rgba(31, 215, 232, 0.873) 60%);
      color: black;
      transform: scale(1.05);
    }

    .overlay-box {
      position: fixed;
      bottom: 0;
      left: 50%;
      transform: translateX(-50%) translateY(100%);
      width: 80%;
      max-width: 900px;
      min-height: 70vh;
      background: rgba(255, 255, 255, 0.15);
      backdrop-filter: blur(25px);
      border-radius: 20px;
      padding: 40px;
      opacity: 0;
      transition: none;
      z-index: 2;
      box-shadow: 0 8px 30px rgba(0, 0, 0, 0.2);
      overflow: hidden;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .content-area h2 {
      margin-bottom: 15px;
      font-size: 1.8rem;
    }

    .content-area ul {
      list-style: none;
      padding: 0;
    }

    .content-area li {
      margin: 10px 0;
      font-size: 1.1rem;
    }

    .tab-buttons {
      position: fixed;
      bottom: 0;
      left: 0;
      width: 100%;
      background: rgba(0,0,0,0.3);
      backdrop-filter: blur(10px);
      padding: 15px 0;
      display: flex;
      justify-content: center;
      gap: 15px;
      z-index: 3;
      opacity: 0;
      transition: none;
    }

    .tab-buttons button {
      padding: 10px 20px;
      background: rgba(0, 0, 0, 0.4);
      border: none;
      border-radius: 10px;
      color: white;
      font-weight: bold;
      cursor: pointer;
      transition: background 0.3s ease;
    }

    .tab-buttons button:hover {
      background: rgba(0, 0, 0, 0.6);
    }

    .reveal-text {
      opacity: 0;
      transform: scale(0.95);
      transition: all 1.2s ease;
    }

    .reveal-text.visible {
      opacity: 1;
      transform: scale(1);
    }

    /* 파티클 시스템 스타일 */
    .particles-container {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 0;
      overflow: hidden;
    }

    .particle {
      position: absolute;
      color: rgba(255, 255, 255, 0.7);
      font-family: 'Courier New', monospace;
      font-size: 16px;
      font-weight: bold;
      animation: float 20s infinite linear;
      pointer-events: none;
      text-shadow: 0 0 10px rgba(255, 255, 255, 0.3);
    }

    .binary-particle {
      color: rgba(39, 147, 206, 0.8);
      font-size: 18px;
      text-shadow: 0 0 15px rgba(39, 147, 206, 0.5);
    }

    @keyframes float {
      0% {
        transform: translateY(0) rotate(0deg) translateX(0px);
        opacity: 0;
      }
      10% {
        opacity: 1;
      }
      50% {
        transform: translateY(-50vh) rotate(180deg) translateX(30px);
        opacity: 0.8;
      }
      90% {
        opacity: 0.6;
      }
      100% {
        transform: translateY(-100vh) rotate(360deg) translateX(-30px);
        opacity: 0;
      }
    }

    /* 마우스 커서 효과 */
    .cursor-glow {
      position: fixed;
      width: 20px;
      height: 20px;
      background: radial-gradient(circle, rgba(39, 147, 206, 0.8) 0%, rgba(39, 147, 206, 0.4) 30%, transparent 70%);
      border-radius: 50%;
      pointer-events: none;
      z-index: 9999;
      mix-blend-mode: screen;
      transition: transform 0.1s ease-out;
    }

    .cursor-trail {
      position: fixed;
      width: 4px;
      height: 4px;
      background: rgba(39, 147, 206, 0.6);
      border-radius: 50%;
      pointer-events: none;
      z-index: 9998;
      transition: all 0.3s ease-out;
    }

    /* 타이핑 효과 스타일 */
    .typing-cursor {
      display: inline-block;
      background-color: #2793ce;
      width: 3px;
      animation: blink 1s infinite;
    }

    @keyframes blink {
      0%, 50% { opacity: 1; }
      51%, 100% { opacity: 0; }
    }

    /* 3D 객체 등장 애니메이션 */
    @keyframes rise-and-rotate {
      0% {
        transform: translateY(200px) rotateY(0deg) rotateX(0deg);
        opacity: 0;
      }
      50% {
        opacity: 0.7;
      }
      100% {
        transform: translateY(0px) rotateY(360deg) rotateX(180deg);
        opacity: 1;
      }
    }

    .object-3d {
      animation: rise-and-rotate 3s ease-out forwards;
    }
  </style>
</head>
<body>

<!-- 파티클 시스템 -->
<div class="particles-container" id="particles"></div>

<!-- 마우스 커서 효과 -->
<div class="cursor-glow" id="cursorGlow"></div>

<header id="main-header" class="p-3 flex items-center justify-between" style="height: 100px; background-color: transparent; position: fixed; top: 0; left: 0; width: 100%; z-index: 1000;">
  <div class="flex items-center">
    <span class="material-icons text-gray-400 mr-3">menu</span>
    <img src="/static/logo.jpg" alt="logo" class="h-36 w-36 object-contain mr-2" style="margin-top: -16px; margin-bottom: -16px;" />
    <span class="text-white font-semibold ml-3 text-lg"></span>
  </div>
  <div class="flex items-center">
    <div class="relative mr-4">
      <input class="bg-gray-700 text-gray-300 placeholder-gray-500 rounded-md py-1.5 px-3 pl-8 focus:outline-none focus:ring-2 focus:ring-blue-500 text-sm" placeholder="/ Type to search" style="width: 300px;" type="text"/>
      <span class="material-icons absolute left-2 top-1/2 transform -translate-y-1/2 text-gray-500 text-lg">search</span>
    </div>
    <a href="/login"><button class="text-gray-300 hover:text-white px-3 py-2 rounded-md text-sm font-medium">로그인</button></a>
    <a href="/signup"><button class="text-gray-300 hover:text-white px-3 py-2 rounded-md text-sm font-medium ml-2">회원가입</button></a>
  </div>
</header>

<div class="hero">
  <div class="reveal-text" id="heroText">
    <h1 id="typingTitle" style="font-size: 2.8rem; font-weight: bold; margin-bottom: 1rem; line-height: 1.2; min-height: 3.4rem;"></h1>
    <p id="typingSubtitle" style="font-size: 1.2rem; color: #d1d5db; min-height: 1.5rem;"></p>
    <a href="/login"><button class="btn" id="startButton" style="opacity: 0; transition: opacity 0.5s ease;">GET STARTED WITH GITHUB</button></a>
  </div>
</div>

<!-- 배경 이미지 -->
<img src="/static/back.png" alt="Background" class="background-image">

<!-- 3D 객체 컨테이너 -->
<div class="hero-3d-container">
  <canvas id="three-canvas"></canvas>
</div>

<div class="overlay-box" id="overlay">
  <div class="content-area" id="content">
    <h2>refactoring</h2>
    <ul>
      <li>✅ Build Linux — 1m 42s</li>
      <li>✅ Build macOS — 1m 24s</li>
      <li>✅ Build Windows — 1m 36s</li>
    </ul>
  </div>
</div>

<div class="tab-buttons" id="buttons">
  <button onclick="showTab('build')">refactoring</button>
  <button onclick="showTab('test')">code review</button>
  <button onclick="showTab('publish')">document</button>
</div>

<script>
  // 3D Scene 설정
  class ThreeJSScene {
    constructor() {
      this.scene = new THREE.Scene();
      this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
      this.renderer = new THREE.WebGLRenderer({ 
        canvas: document.getElementById('three-canvas'),
        alpha: true,
        antialias: true
      });
      
      this.objects = [];
      this.loader = new THREE.GLTFLoader();
      
      // 클릭 감지를 위한 Raycaster 추가
      this.raycaster = new THREE.Raycaster();
      this.mouse = new THREE.Vector2();
      
      this.init();
    }

    init() {
      // 렌더러 설정
      this.renderer.setSize(window.innerWidth, window.innerHeight * 0.8);
      this.renderer.setClearColor(0x000000, 0); // 투명 배경
      this.renderer.shadowMap.enabled = true;
      this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;

      // 캔버스 설정 (CSS에서 이미 클리핑 적용됨)

      // 카메라 위치 설정
      this.camera.position.set(0, 2, 8);
      this.camera.lookAt(0, 0, 0);

      // 조명 설정
      this.setupLights();

      // 3D 객체 로드
      this.loadObjects();

      // 클릭 이벤트 리스너 추가
      this.setupClickEvents();

      // 애니메이션 시작
      this.animate();

      // 윈도우 리사이즈 이벤트
      window.addEventListener('resize', () => this.onWindowResize());
    }

         setupLights() {
       // 기본 환경광 (전체적인 밝기)
       const ambientLight = new THREE.AmbientLight(0x404080, 0.8);
       this.scene.add(ambientLight);

       // === 메인 조명들 ===
       
       // 메인 방향광 (태양광 역할 - 우상단에서)
       const mainDirectionalLight = new THREE.DirectionalLight(0xffffff, 2.0);
       mainDirectionalLight.position.set(15, 20, 10);
       mainDirectionalLight.castShadow = true;
       mainDirectionalLight.shadow.mapSize.width = 4096;
       mainDirectionalLight.shadow.mapSize.height = 4096;
       mainDirectionalLight.shadow.camera.near = 0.1;
       mainDirectionalLight.shadow.camera.far = 100;
       mainDirectionalLight.shadow.camera.left = -20;
       mainDirectionalLight.shadow.camera.right = 20;
       mainDirectionalLight.shadow.camera.top = 20;
       mainDirectionalLight.shadow.camera.bottom = -20;
       this.scene.add(mainDirectionalLight);

       // 보조 방향광 (좌상단에서 - 부드러운 조명)
       const secondaryDirectionalLight = new THREE.DirectionalLight(0xe6f3ff, 1.2);
       secondaryDirectionalLight.position.set(-12, 15, 8);
       this.scene.add(secondaryDirectionalLight);

       // 백라이트 방향광 (뒤쪽에서 - 윤곽선 강조)
       const backLight = new THREE.DirectionalLight(0x80c0ff, 1.0);
       backLight.position.set(0, 8, -15);
       this.scene.add(backLight);

       // === 포인트 라이트들 (다양한 각도) ===
       
       // 전면 좌측 포인트 라이트 (따뜻한 색상)
       const frontLeftLight = new THREE.PointLight(0xfff0e6, 1.5, 25);
       frontLeftLight.position.set(-8, 3, 6);
       this.scene.add(frontLeftLight);

       // 전면 우측 포인트 라이트 (차가운 색상)
       const frontRightLight = new THREE.PointLight(0xe6f0ff, 1.3, 25);
       frontRightLight.position.set(8, 2, 6);
       this.scene.add(frontRightLight);

       // 상단 중앙 포인트 라이트 (밝은 흰색)
       const topCenterLight = new THREE.PointLight(0xffffff, 1.8, 20);
       topCenterLight.position.set(0, 12, 0);
       this.scene.add(topCenterLight);

       // 하단 좌측 포인트 라이트 (파란색 톤)
       const bottomLeftLight = new THREE.PointLight(0x4080ff, 0.8, 15);
       bottomLeftLight.position.set(-6, -2, 3);
       this.scene.add(bottomLeftLight);

       // 하단 우측 포인트 라이트 (주황색 톤)
       const bottomRightLight = new THREE.PointLight(0xff8040, 0.8, 15);
       bottomRightLight.position.set(6, -2, 3);
       this.scene.add(bottomRightLight);

       // 뒤쪽 좌측 포인트 라이트 (보라색 톤)
       const backLeftLight = new THREE.PointLight(0x8040ff, 0.6, 18);
       backLeftLight.position.set(-4, 4, -8);
       this.scene.add(backLeftLight);

       // 뒤쪽 우측 포인트 라이트 (청록색 톤)
       const backRightLight = new THREE.PointLight(0x40ff80, 0.6, 18);
       backRightLight.position.set(4, 4, -8);
       this.scene.add(backRightLight);

       // === 스팟라이트들 (집중 조명) ===
       
       // 좌측 객체 집중 스팟라이트
       const leftSpotLight = new THREE.SpotLight(0xffffff, 1.2, 30, Math.PI / 6, 0.3);
       leftSpotLight.position.set(-10, 8, 5);
       leftSpotLight.target.position.set(-2.5, -1.5, 0.5);
       this.scene.add(leftSpotLight);
       this.scene.add(leftSpotLight.target);

       // 중앙 객체 집중 스팟라이트
       const centerSpotLight = new THREE.SpotLight(0xffffff, 1.2, 30, Math.PI / 6, 0.3);
       centerSpotLight.position.set(0, 10, 8);
       centerSpotLight.target.position.set(0, -0.5, -0.3);
       this.scene.add(centerSpotLight);
       this.scene.add(centerSpotLight.target);

       // 우측 객체 집중 스팟라이트
       const rightSpotLight = new THREE.SpotLight(0xffffff, 1.2, 30, Math.PI / 6, 0.3);
       rightSpotLight.position.set(10, 8, 5);
       rightSpotLight.target.position.set(2.5, -2, 0.3);
       this.scene.add(rightSpotLight);
       this.scene.add(rightSpotLight.target);

       // === 움직이는 조명들 (동적 효과) ===
       
       // 회전하는 컬러 라이트 1
       const rotatingLight1 = new THREE.PointLight(0xff4080, 0.8, 20);
       rotatingLight1.position.set(5, 6, 0);
       this.scene.add(rotatingLight1);
       this.rotatingLights = this.rotatingLights || [];
       this.rotatingLights.push({
         light: rotatingLight1,
         radius: 8,
         speed: 0.01,
         height: 6,
         angle: 0
       });

       // 회전하는 컬러 라이트 2
       const rotatingLight2 = new THREE.PointLight(0x4080ff, 0.8, 20);
       rotatingLight2.position.set(-5, 6, 0);
       this.scene.add(rotatingLight2);
       this.rotatingLights.push({
         light: rotatingLight2,
         radius: 8,
         speed: -0.008,
         height: 6,
         angle: Math.PI
       });

       // 맥동하는 조명 (펄스 효과)
       const pulsingLight = new THREE.PointLight(0x80ff80, 1.0, 25);
       pulsingLight.position.set(0, 0, 10);
       this.scene.add(pulsingLight);
       this.pulsingLight = pulsingLight;

       // === 장식용 조명들 ===
       
       // 원형으로 배치된 작은 조명들
       const circleRadius = 12;
       const numCircleLights = 8;
       this.circleLights = [];
       
       for (let i = 0; i < numCircleLights; i++) {
         const angle = (i / numCircleLights) * Math.PI * 2;
         const x = Math.cos(angle) * circleRadius;
         const z = Math.sin(angle) * circleRadius;
         
         const hue = (i / numCircleLights) * 360;
         const color = new THREE.Color().setHSL(hue / 360, 0.7, 0.6);
         
         const circleLight = new THREE.PointLight(color, 0.4, 15);
         circleLight.position.set(x, 8, z);
         this.scene.add(circleLight);
         
         this.circleLights.push({
           light: circleLight,
           originalIntensity: 0.4,
           phase: i * 0.5
         });
       }

       console.log('고급 다각도 조명 시스템 초기화 완료!');
     }

    loadObjects() {
      const objectPaths = [
        { path: '/static/a.glb', position: [-2.5, -1.5, 0.5], delay: 0, actionType: 'bounce' },
        { path: '/static/b.glb', position: [0, -0.5, -0.3], delay: 0.5, actionType: 'spin' },
        { path: '/static/c.glb', position: [2.5, -2, 0.3], delay: 1.0, actionType: 'pulse' }
      ];

      objectPaths.forEach((objData, index) => {
        this.loader.load(
          objData.path,
          (gltf) => {
            const object = gltf.scene;
            
            // 초기 위치 설정 (아래쪽에서 시작, 처음엔 보이지 않음)
            const startX = objData.position[0];
            const startY = objData.position[1] - 6;
            const startZ = objData.position[2];
            
            object.position.set(startX, startY, startZ);
            object.scale.set(0.7, 0.7, 0.7);
            object.visible = false; // 처음엔 보이지 않음
            
            // 그림자 설정
            object.traverse((child) => {
              if (child.isMesh) {
                child.castShadow = true;
                child.receiveShadow = true;
              }
            });

            this.scene.add(object);
            this.objects.push({
              mesh: object,
              startPosition: [startX, startY, startZ],
              targetPosition: objData.position,
              currentPosition: [startX, startY, startZ],
              rotationSpeed: 0.02 + Math.random() * 0.01,
              delay: objData.delay,
              startTime: Date.now() + (objData.delay * 1000),
              isAnimating: false,
              hasAppeared: false,
              floatOffset: Math.random() * Math.PI * 2, // 각각 다른 부유 패턴
              animationProgress: 0, // 애니메이션 진행도 (0~1)
              actionType: objData.actionType, // 클릭 액션 타입
              
              // 클릭 액션 관련 변수들
              isClickAnimating: false,
              clickAnimationProgress: 0,
              originalScale: [0.7, 0.7, 0.7],
              originalPosition: [...objData.position]
            });
          },
          (progress) => {
            console.log(`Loading ${objData.path}: ${(progress.loaded / progress.total * 100)}%`);
          },
          (error) => {
            console.error(`Error loading ${objData.path}:`, error);
          }
        );
      });
    }

    // 클릭 이벤트 설정
    setupClickEvents() {
      const canvas = this.renderer.domElement;
      
      // 마우스 호버 효과를 위한 스타일 추가
      canvas.style.cursor = 'default';
      
      canvas.addEventListener('click', (event) => {
        this.onMouseClick(event);
      });
      
      canvas.addEventListener('mousemove', (event) => {
        this.onMouseMove(event);
      });
    }

    // 마우스 클릭 처리
    onMouseClick(event) {
      const rect = this.renderer.domElement.getBoundingClientRect();
      
      // 마우스 좌표를 정규화된 장치 좌표(-1 to +1)로 변환
      this.mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
      this.mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

      // Raycaster를 카메라와 마우스 위치로 업데이트
      this.raycaster.setFromCamera(this.mouse, this.camera);

      // 클릭 가능한 객체들 (등장이 완료된 객체들만)
      const clickableObjects = this.objects
        .filter(obj => obj.hasAppeared && !obj.isClickAnimating)
        .map(obj => obj.mesh);

      // 교차점 계산
      const intersects = this.raycaster.intersectObjects(clickableObjects, true);

      if (intersects.length > 0) {
        const clickedObject = intersects[0].object;
        
        // 클릭된 메시의 부모 객체 찾기
        let targetMesh = clickedObject;
        while (targetMesh.parent && !this.objects.find(obj => obj.mesh === targetMesh)) {
          targetMesh = targetMesh.parent;
        }
        
        // 해당 객체 데이터 찾기
        const objectData = this.objects.find(obj => obj.mesh === targetMesh);
        if (objectData) {
          this.triggerClickAction(objectData);
        }
      }
    }

    // 마우스 호버 처리
    onMouseMove(event) {
      const rect = this.renderer.domElement.getBoundingClientRect();
      
      this.mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
      this.mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

      this.raycaster.setFromCamera(this.mouse, this.camera);

      const clickableObjects = this.objects
        .filter(obj => obj.hasAppeared)
        .map(obj => obj.mesh);

      const intersects = this.raycaster.intersectObjects(clickableObjects, true);

      // 커서 스타일 변경
      this.renderer.domElement.style.cursor = intersects.length > 0 ? 'pointer' : 'default';
    }

    // 클릭 액션 트리거
    triggerClickAction(objectData) {
      if (objectData.isClickAnimating) return;
      
      objectData.isClickAnimating = true;
      objectData.clickAnimationProgress = 0;
      
      console.log(`${objectData.actionType} 액션 시작!`);
      
      // 액션 타입에 따라 초기값 설정
      switch (objectData.actionType) {
        case 'bounce':
          objectData.bounceHeight = 1.5;
          objectData.bounceSpeed = 0.08;
          break;
        case 'spin':
          objectData.spinSpeed = 0.15;
          objectData.initialRotationY = objectData.mesh.rotation.y;
          break;
        case 'pulse':
          objectData.pulseScale = 1.4;
          objectData.pulseSpeed = 0.12;
          break;
      }
    }

    // 동적 조명 효과 업데이트
    updateDynamicLights(currentTime) {
      // 회전하는 조명들 업데이트
      if (this.rotatingLights) {
        this.rotatingLights.forEach(rotatingLight => {
          rotatingLight.angle += rotatingLight.speed;
          
          const x = Math.cos(rotatingLight.angle) * rotatingLight.radius;
          const z = Math.sin(rotatingLight.angle) * rotatingLight.radius;
          
          rotatingLight.light.position.x = x;
          rotatingLight.light.position.z = z;
          rotatingLight.light.position.y = rotatingLight.height + Math.sin(currentTime * 0.003) * 2;
        });
      }

      // 맥동하는 조명 업데이트
      if (this.pulsingLight) {
        const pulseIntensity = 1.0 + Math.sin(currentTime * 0.005) * 0.5;
        this.pulsingLight.intensity = pulseIntensity;
        
        // 색상도 변화
        const hue = (currentTime * 0.0005) % 1;
        this.pulsingLight.color.setHSL(hue, 0.7, 0.6);
      }

      // 원형 조명들 트윙클 효과
      if (this.circleLights) {
        this.circleLights.forEach((circleLight, index) => {
          const phase = circleLight.phase + currentTime * 0.001;
          const intensity = circleLight.originalIntensity * (0.5 + Math.sin(phase) * 0.5);
          circleLight.light.intensity = intensity;
          
          // 각 조명마다 다른 색상 변화
          const hue = ((currentTime * 0.0002) + index * 0.125) % 1;
          circleLight.light.color.setHSL(hue, 0.8, 0.7);
        });
      }
    }

    // 클릭 액션 애니메이션 업데이트
    updateClickActions() {
      this.objects.forEach(obj => {
        if (!obj.isClickAnimating) return;
        
        obj.clickAnimationProgress += 0.02;
        
        switch (obj.actionType) {
          case 'bounce':
            this.updateBounceAction(obj);
            break;
          case 'spin':
            this.updateSpinAction(obj);
            break;
          case 'pulse':
            this.updatePulseAction(obj);
            break;
        }
        
        // 애니메이션 완료 체크
        if (obj.clickAnimationProgress >= 1) {
          this.completeClickAction(obj);
        }
      });
    }

    // 바운스 액션 업데이트
    updateBounceAction(obj) {
      const progress = obj.clickAnimationProgress;
      const bounceProgress = Math.sin(progress * Math.PI * 2) * (1 - progress);
      
      const baseY = obj.floatBasePosition ? obj.floatBasePosition[1] : obj.originalPosition[1];
      const bounceY = baseY + bounceProgress * obj.bounceHeight;
      
      obj.mesh.position.y = bounceY;
      
      // 통통 튀는 느낌을 위한 스케일 효과
      const scaleEffect = 1 + Math.abs(bounceProgress) * 0.1;
      obj.mesh.scale.set(
        obj.originalScale[0] * scaleEffect,
        obj.originalScale[1] * scaleEffect,
        obj.originalScale[2] * scaleEffect
      );
    }

    // 스핀 액션 업데이트
    updateSpinAction(obj) {
      const progress = obj.clickAnimationProgress;
      const spinRotation = progress * Math.PI * 4; // 2바퀴 회전
      
      obj.mesh.rotation.y = obj.initialRotationY + spinRotation;
      
      // 회전하면서 살짝 위아래로 움직이는 효과
      const bobEffect = Math.sin(progress * Math.PI * 8) * 0.2;
      const baseY = obj.floatBasePosition ? obj.floatBasePosition[1] : obj.originalPosition[1];
      obj.mesh.position.y = baseY + bobEffect;
      
      // 회전 속도가 점점 느려지는 효과
      const easeOut = 1 - Math.pow(1 - progress, 3);
      obj.mesh.rotation.y = obj.initialRotationY + easeOut * Math.PI * 4;
    }

    // 펄스 액션 업데이트
    updatePulseAction(obj) {
      const progress = obj.clickAnimationProgress;
      const pulseProgress = Math.sin(progress * Math.PI * 2);
      
      const scaleMultiplier = 1 + pulseProgress * (obj.pulseScale - 1) * 0.5;
      obj.mesh.scale.set(
        obj.originalScale[0] * scaleMultiplier,
        obj.originalScale[1] * scaleMultiplier,
        obj.originalScale[2] * scaleMultiplier
      );
      
      // 펄스와 함께 색상 효과 (발광 효과)
      const glowIntensity = Math.abs(pulseProgress) * 0.3;
      obj.mesh.traverse((child) => {
        if (child.isMesh && child.material) {
          if (!child.originalEmissive) {
            child.originalEmissive = child.material.emissive ? child.material.emissive.clone() : new THREE.Color(0x000000);
          }
          
          const emissiveColor = new THREE.Color(0x2793ce);
          emissiveColor.multiplyScalar(glowIntensity);
          
          if (child.material.emissive) {
            child.material.emissive.copy(child.originalEmissive).add(emissiveColor);
          }
        }
      });
    }

    // 클릭 액션 완료 처리
    completeClickAction(obj) {
      obj.isClickAnimating = false;
      obj.clickAnimationProgress = 0;
      
      // 원래 상태로 복원
      obj.mesh.scale.set(...obj.originalScale);
      
      // 원래 위치로 복원 (부유 효과 고려)
      if (obj.floatBasePosition) {
        const currentTime = Date.now();
        const floatY = obj.floatBasePosition[1] + Math.sin(currentTime * 0.002 + obj.floatOffset) * 0.25;
        const floatX = obj.floatBasePosition[0] + Math.cos(currentTime * 0.0015 + obj.floatOffset) * 0.08;
        const floatZ = obj.floatBasePosition[2] + Math.sin(currentTime * 0.0018 + obj.floatOffset) * 0.08;
        
        obj.mesh.position.set(floatX, floatY, floatZ);
      }
      
      // 원래 회전으로 복원
      if (obj.finalRotationY !== undefined) {
        obj.mesh.rotation.y = obj.finalRotationY;
        obj.mesh.rotation.x = obj.finalRotationX;
        obj.mesh.rotation.z = obj.finalRotationZ;
      }
      
      // 발광 효과 제거
      obj.mesh.traverse((child) => {
        if (child.isMesh && child.material && child.originalEmissive) {
          if (child.material.emissive) {
            child.material.emissive.copy(child.originalEmissive);
          }
        }
      });
      
      console.log(`${obj.actionType} 액션 완료!`);
    }

    animate() {
      requestAnimationFrame(() => this.animate());

      const currentTime = Date.now();

      // 동적 조명 효과 업데이트
      this.updateDynamicLights(currentTime);

      // 클릭 액션 애니메이션 업데이트
      this.updateClickActions();

      // 각 객체 애니메이션 업데이트
      this.objects.forEach((obj) => {
        // 클릭 애니메이션 중이면 기본 애니메이션 스킵
        if (obj.isClickAnimating) return;
        
        // 등장 애니메이션 시작
        if (!obj.isAnimating && currentTime >= obj.startTime) {
          obj.isAnimating = true;
          obj.mesh.visible = true; // 등장 시작할 때 보이게 함
        }

        if (obj.isAnimating) {
          // 등장 애니메이션 (모든 축에서 부드럽게 이동)
          if (obj.animationProgress < 1) {
            obj.animationProgress += 0.008; // 애니메이션 속도 조정
            
            // 더 부드러운 이징 함수 (cubic-bezier 스타일)
            const t = obj.animationProgress;
            const easeProgress = t * t * (3 - 2 * t); // smoothstep 함수
            
            // 모든 축에서 보간
            const currentX = obj.startPosition[0] + (obj.targetPosition[0] - obj.startPosition[0]) * easeProgress;
            const currentY = obj.startPosition[1] + (obj.targetPosition[1] - obj.startPosition[1]) * easeProgress;
            const currentZ = obj.startPosition[2] + (obj.targetPosition[2] - obj.startPosition[2]) * easeProgress;
            
            obj.mesh.position.set(currentX, currentY, currentZ);
            obj.currentPosition = [currentX, currentY, currentZ];
            
            // 회전 애니메이션 개선 - 더 자연스러운 감속
            const rotationEase = Math.pow(1 - easeProgress, 3); // 더 부드러운 감속 곡선
            const rotationIntensity = rotationEase * 0.6 + 0.05;
            
            // 회전 속도를 누적하지 않고 목표 회전값으로 부드럽게 이동
            if (!obj.targetRotationY) {
              obj.targetRotationY = obj.mesh.rotation.y + (Math.PI * 2 * (1 + Math.random() * 0.5));
              obj.targetRotationX = obj.mesh.rotation.x + (Math.PI * (0.5 + Math.random() * 0.3));
              obj.initialRotationY = obj.mesh.rotation.y;
              obj.initialRotationX = obj.mesh.rotation.x;
            }
            
            // 회전을 목표값으로 부드럽게 보간
            const rotationProgress = 1 - rotationEase;
            obj.mesh.rotation.y = obj.initialRotationY + (obj.targetRotationY - obj.initialRotationY) * rotationProgress;
            obj.mesh.rotation.x = obj.initialRotationX + (obj.targetRotationX - obj.initialRotationX) * rotationProgress;
            
          } else {
            // 등장 완료
            if (!obj.hasAppeared) {
              obj.hasAppeared = true;
              // 최종 위치 설정
              obj.mesh.position.set(obj.targetPosition[0], obj.targetPosition[1], obj.targetPosition[2]);
              
              // 부유 효과를 위한 기준점 설정
              obj.floatBasePosition = [...obj.targetPosition];
              
              // 정면을 바라보도록 회전 설정 (약간의 개성을 위해 미세한 차이 적용)
              obj.finalRotationY = Math.random() * 0.2 - 0.1; // -0.1 ~ 0.1 라디안
              obj.finalRotationX = Math.random() * 0.1 - 0.05; // -0.05 ~ 0.05 라디안
              obj.finalRotationZ = Math.random() * 0.1 - 0.05; // -0.05 ~ 0.05 라디안
              
              // 정면 방향으로 부드럽게 회전하는 애니메이션을 위한 변수
              obj.rotationTransitionProgress = 0;
              obj.currentRotationY = obj.mesh.rotation.y;
              obj.currentRotationX = obj.mesh.rotation.x;
              obj.currentRotationZ = obj.mesh.rotation.z;
            }
            
            // 정면을 바라보도록 부드럽게 회전 전환
            if (obj.rotationTransitionProgress < 1) {
              obj.rotationTransitionProgress += 0.015; // 전환 속도
              const transitionEase = obj.rotationTransitionProgress * obj.rotationTransitionProgress * (3 - 2 * obj.rotationTransitionProgress);
              
              // 현재 회전에서 목표 회전으로 부드럽게 전환
              obj.mesh.rotation.y = obj.currentRotationY + (obj.finalRotationY - obj.currentRotationY) * transitionEase;
              obj.mesh.rotation.x = obj.currentRotationX + (obj.finalRotationX - obj.currentRotationX) * transitionEase;
              obj.mesh.rotation.z = obj.currentRotationZ + (obj.finalRotationZ - obj.currentRotationZ) * transitionEase;
            } else {
              // 정면을 바라본 상태에서 매우 미세한 흔들림만 (둥둥 떠있는 느낌)
              obj.mesh.rotation.y = obj.finalRotationY + Math.sin(currentTime * 0.0005 + obj.floatOffset) * 0.03;
              obj.mesh.rotation.x = obj.finalRotationX + Math.cos(currentTime * 0.0004 + obj.floatOffset) * 0.02;
              obj.mesh.rotation.z = obj.finalRotationZ + Math.sin(currentTime * 0.0006 + obj.floatOffset) * 0.02;
            }
            
            // 등장 후 부드러운 부유 효과
            const floatY = obj.floatBasePosition[1] + Math.sin(currentTime * 0.002 + obj.floatOffset) * 0.25;
            const floatX = obj.floatBasePosition[0] + Math.cos(currentTime * 0.0015 + obj.floatOffset) * 0.08;
            const floatZ = obj.floatBasePosition[2] + Math.sin(currentTime * 0.0018 + obj.floatOffset) * 0.08;
            
            obj.mesh.position.set(floatX, floatY, floatZ);
          }
        }
      });

      this.renderer.render(this.scene, this.camera);
    }

    onWindowResize() {
      this.camera.aspect = window.innerWidth / window.innerHeight;
      this.camera.updateProjectionMatrix();
      this.renderer.setSize(window.innerWidth, window.innerHeight * 0.8);
    }
  }

  // 기존 코드들...
  const overlay = document.getElementById('overlay');
  const buttons = document.getElementById('buttons');
  const content = document.getElementById('content');

  const contentMap = {
    build: `
      <video 
        src="/static/1.mp4" 
        controls 
        autoplay 
        muted 
        loop 
        style="
          width: 100%;
          height: auto;
          max-height: 60vh;
          object-fit: contain;
          border-radius: 12px;
          box-shadow: 0 0 20px rgba(0,0,0,0.3);">
      </video>
    `,
    test: `
      <video 
        src="/static/2.mp4" 
        controls 
        autoplay 
        muted 
        loop 
        style="
          width: 100%;
          height: auto;
          max-height: 60vh;
          object-fit: contain;
          border-radius: 12px;
          box-shadow: 0 0 20px rgba(0,0,0,0.3);">
      </video>
    `,
    publish: `
      <video 
        src="/static/3.mp4" 
        controls 
        autoplay 
        muted 
        loop 
        style="
          width: 100%;
          height: auto;
          max-height: 60vh;
          object-fit: contain;
          border-radius: 12px;
          box-shadow: 0 0 20px rgba(0,0,0,0.3);">
      </video>
    `
  };

  function showTab(tab) {
    content.innerHTML = contentMap[tab];
  }

  let overlayInitialized = false;

  window.addEventListener('scroll', () => {
    const scrollY = window.scrollY;
    const startScroll = 300;
    const maxScroll = 1000;

    if (scrollY > startScroll) {
      const effectiveScroll = scrollY - startScroll;
      const scrollRatio = Math.min(effectiveScroll / maxScroll, 1);
      const translateY = 100 - (scrollRatio * 120);
      const opacity = scrollRatio;

      overlay.style.transform = `translateX(-50%) translateY(${translateY}%)`;
      overlay.style.opacity = opacity;
      overlay.classList.add('active');

      if (scrollRatio > 0.85) {
        const buttonOpacity = (scrollRatio - 0.85) / 0.15;
        buttons.style.opacity = buttonOpacity;
        buttons.classList.add('active');
      } else {
        buttons.style.opacity = 0;
        buttons.classList.remove('active');
      }

      if (!overlayInitialized && scrollRatio > 0.2) {
        showTab('build');
        overlayInitialized = true;
      }

    } else {
      overlay.style.transform = `translateX(-50%) translateY(100%)`;
      overlay.style.opacity = 0;
      overlay.classList.remove('active');
      buttons.style.opacity = 0;
      buttons.classList.remove('active');

      overlayInitialized = false;
    }
  });

  const heroText = document.getElementById('heroText');
  const observer = new IntersectionObserver(entries => {
    entries.forEach(entry => {
      if (entry.isIntersecting) {
        heroText.classList.remove('visible');
        void heroText.offsetWidth;
        heroText.classList.add('visible');
      }
    });
  }, { threshold: 0.5 });

  observer.observe(heroText);

  // 파티클 시스템 구현
  class ParticleSystem {
    constructor() {
      this.container = document.getElementById('particles');
      this.particles = [];
      this.codeSymbols = ['{', '}', '(', ')', '[', ']', '<', '>', '/', '*', '+', '-', '=', ';', ':', '.', ',', 'if', 'for', 'var', 'let', 'const'];
      this.binarySymbols = ['0', '1', '01', '10', '101', '010'];
      
      console.log('파티클 시스템 초기화 중...');
      console.log('파티클 컨테이너:', this.container);
      
      if (!this.container) {
        console.error('파티클 컨테이너를 찾을 수 없습니다!');
        return;
      }
      
      this.init();
    }

    init() {
      console.log('파티클 생성 시작...');
      
      for (let i = 0; i < 30; i++) {
        setTimeout(() => this.createParticle(), i * 100);
      }
      
      console.log(`파티클 생성 시작됨`);
      
      setInterval(() => {
        if (this.particles.length < 50) {
          this.createParticle();
        }
        // 주기적으로 완료된 파티클 정리
        this.cleanupParticles();
      }, 800);
    }

    createParticle() {
      if (!this.container) return;
      
      const particle = document.createElement('div');
      const isBinary = Math.random() > 0.5;
      particle.className = isBinary ? 'particle binary-particle' : 'particle';
      
      const symbols = isBinary ? this.binarySymbols : this.codeSymbols;
      particle.textContent = symbols[Math.floor(Math.random() * symbols.length)];
      
      const leftPosition = Math.random() * 100;
      particle.style.left = leftPosition + '%';
      particle.style.bottom = '-50px';
      
      const animationDelay = Math.random() * 3;
      const animationDuration = 12 + Math.random() * 8;
      
      particle.style.animationDelay = animationDelay + 's';
      particle.style.animationDuration = animationDuration + 's';
      
      const scale = isBinary ? (1.0 + Math.random() * 0.5) : (0.8 + Math.random() * 0.7);
      particle.style.fontSize = (isBinary ? 18 : 16) * scale + 'px';
      particle.style.opacity = 0.4 + Math.random() * 0.4;
      
      if (isBinary) {
        particle.style.color = `rgba(39, 147, 206, ${0.6 + Math.random() * 0.4})`;
        particle.style.textShadow = '0 0 10px rgba(39, 147, 206, 0.8)';
      } else {
        particle.style.color = `rgba(255, 255, 255, ${0.5 + Math.random() * 0.3})`;
        particle.style.textShadow = '0 0 8px rgba(255, 255, 255, 0.5)';
      }
      
      // 파티클 정보 저장
      const particleData = {
        element: particle,
        createdTime: Date.now(),
        animationDelay: animationDelay * 1000,
        animationDuration: animationDuration * 1000,
        isRemoving: false
      };
      
      this.container.appendChild(particle);
      this.particles.push(particleData);
      
      // 애니메이션 완료 후 자연스럽게 제거
      const totalLifetime = (animationDelay + animationDuration) * 1000;
      setTimeout(() => {
        this.removeParticle(particleData);
      }, totalLifetime + 1000); // 1초 여유시간 추가
    }

    removeParticle(particleData) {
      if (particleData.isRemoving) return;
      
      particleData.isRemoving = true;
      const particle = particleData.element;
      
      if (particle && particle.parentNode) {
        // 자연스러운 페이드아웃 효과
        particle.style.transition = 'opacity 0.5s ease-out';
        particle.style.opacity = '0';
        
        setTimeout(() => {
          if (particle.parentNode) {
            particle.parentNode.removeChild(particle);
          }
          this.particles = this.particles.filter(p => p !== particleData);
        }, 500);
      }
    }

    cleanupParticles() {
      const currentTime = Date.now();
      const particlesToRemove = [];
      
      this.particles.forEach(particleData => {
        const totalLifetime = particleData.animationDelay + particleData.animationDuration;
        const elapsed = currentTime - particleData.createdTime;
        
        // 예상 생명주기를 초과한 파티클들 찾기
        if (elapsed > totalLifetime + 2000 && !particleData.isRemoving) {
          particlesToRemove.push(particleData);
        }
      });
      
      // 찾은 파티클들 제거
      particlesToRemove.forEach(particleData => {
        this.removeParticle(particleData);
      });
    }
  }

  // 마우스 커서 효과 구현
  class CursorEffect {
    constructor() {
      this.cursorGlow = document.getElementById('cursorGlow');
      this.trails = [];
      this.maxTrails = 8;
      this.init();
    }

    init() {
      for (let i = 0; i < this.maxTrails; i++) {
        const trail = document.createElement('div');
        trail.className = 'cursor-trail';
        trail.style.opacity = (this.maxTrails - i) / this.maxTrails * 0.6;
        trail.style.transform = 'scale(' + (this.maxTrails - i) / this.maxTrails + ')';
        document.body.appendChild(trail);
        this.trails.push({
          element: trail,
          x: 0,
          y: 0
        });
      }

      document.addEventListener('mousemove', (e) => {
        this.updateCursor(e.clientX, e.clientY);
      });

      document.addEventListener('mouseenter', () => {
        this.cursorGlow.style.opacity = '1';
        this.trails.forEach(trail => trail.element.style.opacity = trail.element.style.opacity);
      });

      document.addEventListener('mouseleave', () => {
        this.cursorGlow.style.opacity = '0';
        this.trails.forEach(trail => trail.element.style.opacity = '0');
      });
    }

    updateCursor(x, y) {
      this.cursorGlow.style.left = (x - 10) + 'px';
      this.cursorGlow.style.top = (y - 10) + 'px';

      this.trails.forEach((trail, index) => {
        setTimeout(() => {
          trail.x = x;
          trail.y = y;
          trail.element.style.left = (trail.x - 2) + 'px';
          trail.element.style.top = (trail.y - 2) + 'px';
        }, index * 50);
      });
    }
  }

  // 타이핑 효과 구현
  class TypingEffect {
    constructor() {
      this.titleElement = document.getElementById('typingTitle');
      this.subtitleElement = document.getElementById('typingSubtitle');
      this.buttonElement = document.getElementById('startButton');
      
      this.titleText = '개발자와 AI의 새로운 협업 방식';
      this.subtitleText = '코드 리뷰, 리팩토링, 문서화까지 하나의 챗봇으로 빠르고 정확하게';
      
      this.titleIndex = 0;
      this.subtitleIndex = 0;
      this.titleSpeed = 100;
      this.subtitleSpeed = 50;
      
      this.init();
    }

    init() {
      setTimeout(() => {
        this.typeTitle();
      }, 1000);
    }

    typeTitle() {
      if (this.titleIndex < this.titleText.length) {
        this.titleElement.innerHTML = this.titleText.substring(0, this.titleIndex + 1) + '<span class="typing-cursor">&nbsp;</span>';
        this.titleIndex++;
        setTimeout(() => this.typeTitle(), this.titleSpeed);
      } else {
        this.titleElement.innerHTML = this.titleText;
        setTimeout(() => this.typeSubtitle(), 500);
      }
    }

    typeSubtitle() {
      if (this.subtitleIndex < this.subtitleText.length) {
        this.subtitleElement.innerHTML = this.subtitleText.substring(0, this.subtitleIndex + 1) + '<span class="typing-cursor">&nbsp;</span>';
        this.subtitleIndex++;
        setTimeout(() => this.typeSubtitle(), this.subtitleSpeed);
      } else {
        this.subtitleElement.innerHTML = this.subtitleText;
        setTimeout(() => {
          this.buttonElement.style.opacity = '1';
        }, 500);
      }
    }
  }

  // 시스템 초기화
  document.addEventListener('DOMContentLoaded', () => {
    new ParticleSystem();
    new CursorEffect();
    new TypingEffect();
    
    // 3D Scene 초기화 (약간의 지연 후)
    setTimeout(() => {
      new ThreeJSScene();
    }, 1000);
  });
</script>

</body>
</html>
